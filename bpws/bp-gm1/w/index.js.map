{
  "version": 3,
  "sources": ["../src/encode/bullpress/cowrle.js", "../src/encode/bullpress/BWT.js", "../src/encode/bullpress/huffman.js", "../src/encode/bullpress/blocks/cst.js", "../src/encode/bullpress/blocks/casing.js", "../src/encode/bullpress/blocks/avoidE.js", "../src/encode/bullpress/blocks/bracketE.js", "../src/encode/bullpress/blocks/base64.js", "../src/encode/bullpress/bullpress.js", "../src/encode/bullpress/index.js"],
  "sourcesContent": ["// An account service for cows.\n// Copyright (C) 2024  SpectCOW\n\n/*\n * COWRLE - Compact Oversimplified Wonderful RLE\n * Copyright (C) 2024  SpectCOW\n */\n\nfunction* encodeCOWRLEGenerator(input) {\n  let encoded = \"\",\n    lastCount = (i = 0),\n    count = 1,\n    inBrackets = !1,\n    processChar = (char, nextChar) => {\n      if (char === nextChar) {\n        count++;\n      } else {\n        handleUniqueChar(char);\n      }\n    },\n    handleUniqueChar = (char) => {\n      if (count > 1) {\n        handleRepeatedChar(char);\n      } else {\n        handleSingleChar(char);\n      }\n\n      finalizeEncoding();\n    },\n    handleRepeatedChar = (char) => {\n      if (!inBrackets) {\n        encoded += \"[\";\n        inBrackets = !0;\n      }\n\n      if (lastCount != count) {\n        encoded += count;\n        lastCount = count;\n      }\n\n      encoded += char;\n    },\n    handleSingleChar = (char) => {\n      if (inBrackets) {\n        encoded += \"]\";\n        inBrackets = !1;\n      }\n\n      encoded += char;\n    },\n    finalizeEncoding = () => {\n      if (i == input.length - 1 && inBrackets) {\n        encoded += \"]\";\n      }\n\n      count = 1;\n    };\n\n  {\n    try {\n      for (; i < input.length; i++) {\n        processChar(input[i], input[i + 1]);\n        yield encoded;\n        encoded = \"\";\n      }\n    } catch (e) {\n      console.error(\"Failed to encode COWRLE:\", e);\n    } finally {\n      // Cleanup Memory for Return\n      encoded = null;\n    }\n  }\n}\n\nfunction* decodeCOWRLEGenerator(input) {\n  let decoded = \"\",\n    count = \"\",\n    inBrackets = !1,\n    lastCount = 1,\n    i = 0,\n    processCharacter = (character) => {\n      if (character === \"[\") {\n        inBrackets = true;\n        return;\n      }\n\n      if (character === \"]\") {\n        inBrackets = false;\n        return;\n      }\n\n      if (character !== \" \" && !isNaN(character)) {\n        updateCount(character);\n      } else {\n        handleCharacter(character);\n      }\n    },\n    updateCount = (character) => {\n      count += character;\n      lastCount = parseInt(count);\n    },\n    handleCharacter = (character) => {\n      if (parseInt(count) !== 0 && parseInt(count) !== lastCount) {\n        decoded += character.repeat(lastCount);\n      } else if (parseInt(count) == lastCount) {\n        decoded += character.repeat(parseInt(count));\n        count = \"0\";\n      } else {\n        if (inBrackets)\n          decoded += character.repeat(parseInt(count) || lastCount);\n        else decoded += character;\n      }\n    };\n\n  try {\n    for (; i < input.length; i++) {\n      processCharacter(input[i]);\n      yield decoded;\n      decoded = \"\";\n    }\n  } catch (e) {\n    console.error(\"Failed to decode COWRLE:\", e);\n  } finally {\n    // Cleanup Memory for Return\n    decoded = null;\n  }\n}\n\nfunction encodeCOWRLE(input) {\n  return [...encodeCOWRLEGenerator(input)].join(\"\");\n}\n\nfunction decodeCOWRLE(input) {\n  return [...decodeCOWRLEGenerator(input)].join(\"\");\n}\n\n// Example usage:\n// const originalString = \"I am a SUUUUUUUUUUUUUUUUPERRRRRRRRR big fiiiillleeeee\";\n// console.log(\"Origini String: \", originalString);\n\n// const encodedString = encodeCOWRLE(originalString);\n// console.log(\"Encoded String: \", encodedString);\n\n// const decodedString = decodeCOWRLE(encodedString);\n// console.log(\"Decoded String: \", decodedString);\n\n// console.log(\"Result: \", (originalString === decodedString))\n\nconst eobj = {\n  encodeCOWRLE,\n  decodeCOWRLE,\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.cowrle = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;", "// An account service for cows.\n// Copyright (C) 2024  SpectCOW\n\n/** \n  * BWT - Burrows-Wheeler Transform\n  */\n\nfunction burrowsWheelerTransform(input) {\n  const rotations = [];\n\n  // Generate rotations of the input string\n  for (let i = 0; i < input.length; i++) {\n    const rotation = input.slice(i) + input.slice(0, i);\n    rotations.push(rotation);\n  }\n\n  // Sort rotations lexicographically\n  rotations.sort();\n\n  // Extract the last characters of each rotation to form the transformed string\n  let transformedString = \"\";\n  for (let i = 0; i < rotations.length; i++) {\n    transformedString += rotations[i][input.length - 1];\n  }\n\n  // Find the original string's index in the sorted rotations\n  let originalIndex;\n  for (let i = 0; i < rotations.length; i++) {\n    if (rotations[i] === input) {\n      originalIndex = i;\n      break;\n    }\n  }\n\n  return { transformedString, originalIndex };\n}\n\nfunction inverseBurrowsWheelerTransform(transformedString, originalIndex) {\n  const table = [];\n\n  // Construct the Burrows-Wheeler transformation table\n  for (let i = 0; i < transformedString.length; i++) {\n    table.push({ char: transformedString[i], index: i });\n  }\n\n  // Sort the table lexicographically\n  table.sort((a, b) => {\n    if (a.char < b.char) return -1;\n    if (a.char > b.char) return 1;\n    return 0;\n  });\n\n  // Reconstruct the original string using the first column of the sorted table and originalIndex\n  let originalString = \"\";\n  let currentIndex = originalIndex;\n  for (let i = 0; i < transformedString.length; i++) {\n    originalString += table[currentIndex].char;\n    currentIndex = table[currentIndex].index;\n  }\n\n  return originalString;\n}\n\n// Example usage\n// const inputString = \"banana\";\n// const { transformedString, originalIndex } =\n//   burrowsWheelerTransform(inputString);\n// console.log(\"Transformed string:\", transformedString);\n// console.log(\"Original index:\", originalIndex);\n// console.log(\n//   \"Original string:\",\n//   inverseBurrowsWheelerTransform(transformedString, originalIndex),\n// );\n\nconst eobj = {\n  burrowsWheelerTransform,\n  inverseBurrowsWheelerTransform,\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.bwt = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;", "// An account service for cows.\n// Copyright (C) 2024  SpectCOW\n\nclass HuffmanNode {\n  constructor(char, freq) {\n    this.char = char;\n    this.freq = freq;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction buildFrequencyMap(str) {\n  const freqMap = {};\n  for (let i = 0; i < str.length; i++) {\n    if (freqMap.hasOwnProperty(str[i])) {\n      freqMap[str[i]]++;\n    } else {\n      freqMap[str[i]] = 1;\n    }\n  }\n  return freqMap;\n}\n\nfunction buildHuffmanTree(freqMap) {\n  const nodes = [];\n  for (let char in freqMap) {\n    nodes.push(new HuffmanNode(char, freqMap[char]));\n  }\n  while (nodes.length > 1) {\n    nodes.sort((a, b) => a.freq - b.freq);\n    const left = nodes.shift();\n    const right = nodes.shift();\n    const newNode = new HuffmanNode(null, left.freq + right.freq);\n    newNode.left = left;\n    newNode.right = right;\n    nodes.push(newNode);\n  }\n  return nodes[0];\n}\n\nfunction buildCodeMap(node, code = \"\", codeMap = {}) {\n  if (node.char !== null) {\n    codeMap[node.char] = code;\n  } else {\n    buildCodeMap(node.left, code + \"0\", codeMap);\n    buildCodeMap(node.right, code + \"1\", codeMap);\n  }\n  return codeMap;\n}\n\nfunction encode(str, codeMap) {\n  let encoded = \"\";\n  for (let i = 0; i < str.length; i++) {\n    encoded += codeMap[str[i]];\n  }\n  return encoded;\n}\n\nfunction compress(str) {\n  const freqMap = buildFrequencyMap(str);\n  const huffmanTree = buildHuffmanTree(freqMap);\n  const codeMap = buildCodeMap(huffmanTree);\n  const encoded = encode(str, codeMap);\n  return { encoded, codeMap };\n}\n\nfunction decompress(encoded, codeMap) {\n  let decoded = \"\";\n  let currentCode = \"\";\n  for (let i = 0; i < encoded.length; i++) {\n    currentCode += encoded[i];\n    for (let char in codeMap) {\n      if (codeMap[char] === currentCode) {\n        decoded += char;\n        currentCode = \"\";\n        break;\n      }\n    }\n  }\n  return decoded;\n}\n\n// Example usage\n// const originalString = \"hello world\";\n// const compressedData = compress(originalString);\n// console.log(\"Compressed data:\", compressedData.encoded);\n// console.log(\"Code map:\", compressedData.codeMap);\n// const decompressedString = decompress(\n//   compressedData.encoded,\n//   compressedData.codeMap,\n// );\n// console.log(\"Decompressed string:\", decompressedString);\n\nconst eobj = {\n  buildFrequencyMap,\n  buildHuffmanTree,\n  buildCodeMap,\n  encode,\n  compress,\n  decompress,\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.huffman = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;", "const CHUNK_LENGTH = 1024 * 8;\nconst CHUCK_LENGTH_SPEED = 270;\nconst CHAR_EXCHANGE_COST = CHUCK_LENGTH_SPEED / CHUNK_LENGTH;\n\nfunction calculateCost(string) {\n  return string.length * CHAR_EXCHANGE_COST;\n}\n\nfunction calculateChunks(string) {\n  return Math.ceil(string.length / CHUNK_LENGTH);\n}\n\nconst eobj = {\n  CHUNK_LENGTH,\n  CHUCK_LENGTH_SPEED,\n  CHAR_EXCHANGE_COST,\n  \n  calculateCost,\n  calculateChunks,\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.cst = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;", "const eobj = {\n  // Format: <BWT:{ transformedString }|{ originalIndex }:>\n  caseChunk({ transformedString, originalIndex }) {\n    return `<Bull_Chunk:${transformedString}|${originalIndex}:>`;\n  },\n\n  caseBull({ chunk }) {\n    return `<Bull:${chunk}:>`;\n  },\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.casing = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;", "const eobj = {\n  encode(input) {\n    // Escape any Special Characters\n    const caser = (_) => `(${_})`;\n    return input.replace(/\\d+/g, (match) =>\n      caser(\n        match\n          .split(\"\")\n          .map((digit) =>\n            String.fromCharCode(\"A\".charCodeAt(0) + parseInt(digit)),\n          )\n          .join(\"\"),\n      ),\n    );\n  },\n\n  decode(input) {\n    return input.replace(/\\((.*?)\\)/g, (match, p1) =>\n      p1\n        .split(\"\")\n        .map((char) => char.charCodeAt(0) - \"A\".charCodeAt(0))\n        .join(\"\"),\n    );\n  },\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.AvoidEnc = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;", "const eobj = {\n  encode(input) {\n    return (\n      input\n        .replace(/\\]\\(/g, \"\u03E2\")\n        .replace(/\\)\\[/g, \"\u03E3\")\n\n        .replace(/\\]\\{/g, \"\u03E0\")\n        .replace(/\\}\\[/g, \"\u03E1\")\n\n        .replace(/\\)\\{/g, \"\u03DE\")\n        .replace(/\\}\\(/g, \"\u03DF\")\n\n        // SIMPLE (Must be below, for some reason)\n\n        .replace(/\\(\\[/g, \"{\")\n        .replace(/\\]\\)/g, \"}\")\n\n        .replace(/\\[\\(/g, \"<\")\n        .replace(/\\)\\]/g, \">\")\n    );\n  },\n\n  decode(input) {\n    return (\n      input\n\n        .replace(/\u03E2/g, \"](\")\n        .replace(/\u03E3/g, \")[\")\n\n        .replace(/\u03E0/g, \"]{\")\n        .replace(/\u03E1/g, \"}[\")\n\n        .replace(/\u03DE/g, \"){\")\n        .replace(/\u03DF/g, \"}(\")\n\n        // SIMPLE (Must be below, for some reason)\n\n        .replace(/\\{/g, \"([\")\n        .replace(/\\}/g, \"])\")\n\n        .replace(/\\</g, \"[(\")\n        .replace(/\\>/g, \")]\")\n    );\n  },\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.BracketEncoder = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;", "// No Buffer :(, we must manual\nconst base64 = {\n  chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n\n  encode(input = \"\") {\n    let chars = this.chars,\n      output = \"\",\n      i = 0;\n\n    while (i < input.length) {\n      let a = input.charCodeAt(i++),\n        b = input.charCodeAt(i++),\n        c = input.charCodeAt(i++),\n        index1 = a >> 2,\n        index2 = ((a & 3) << 4) | (b >> 4),\n        index3 = isNaN(b) ? 64 : ((b & 15) << 2) | (c >> 6),\n        index4 = isNaN(c) ? 64 : c & 63;\n\n      output += [index1, index2, index3, index4]\n        .map((index) => chars[index])\n        .join(\"\");\n    }\n\n    output = output\n      .replace(/=+$/, \"\")\n\n    return output;\n  },\n\n  decode(input = \"\") {\n    let chars = this.chars,\n      output = \"\",\n      i = 0;\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    while (i < input.length) {\n      let index1 = chars.indexOf(input.charAt(i++)),\n        index2 = chars.indexOf(input.charAt(i++)),\n        index3 = chars.indexOf(input.charAt(i++)),\n        index4 = chars.indexOf(input.charAt(i++)),\n        a = (index1 << 2) | (index2 >> 4),\n        b = ((index2 & 15) << 4) | (index3 >> 2),\n        c = ((index3 & 3) << 6) | index4;\n\n      output += String.fromCharCode(a);\n      if (index3 !== 64) output += String.fromCharCode(b);\n      if (index4 !== 64) output += String.fromCharCode(c);\n    }\n\n    output = output\n      .replace(/[\\x00\\uffff]+$/g, \"\")\n\n    return output;\n  },\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.base64 = base64;\n\nif (typeof globalThis.Buffer !== \"undefined\")\n  module.exports = {\n    encode(input) {\n      return globalThis.Buffer.from(input).toString(\"base64\");\n    },\n\n    decode(input) {\n      return globalThis.Buffer.from(input, \"base64\").toString(\"ascii\");\n    },\n  };\nelse if (typeof module !== \"undefined\") module.exports = base64;\n", "// An account service for cows.\n// Copyright (C) 2024  SpectCOW\n\nconst Cowrle = require(\"./cowrle\");\nconst BWT = require(\"./BWT\");\nconst Huffman = require(\"./huffman\");\n\nconst {\n  CHUNK_LENGTH,\n  CHUCK_LENGTH_SPEED,\n  CHAR_EXCHANGE_COST,\n  \n  calculateCost,\n  calculateChunks,\n} = require(\"./blocks/cst\");\n\nconst casing = require(\"./blocks/casing\");\n\nconst AvoidEnc = require(\"./blocks/avoidE\")\n\nconst BracketEncoder = require(\"./blocks/bracketE\");\n\nconst base64 = require(\"./blocks/base64\");\n\nfunction encodeBullpress(input, chunkSize = CHUNK_LENGTH) {\n  // Chunk parsing for big data\n  let encodedResult = \"\";\n  for (let i = 0; i < input.length; i += chunkSize) {\n    let chunk = input.substring(i, Math.min(i + chunkSize, input.length)),\n      basedKey = base64.encode(chunk),\n      res1 = BWT.burrowsWheelerTransform(basedKey),\n      numbedKey = AvoidEnc.encode(res1.transformedString),\n      cowrString = Cowrle.encodeCOWRLE(numbedKey),\n      transformedString = BracketEncoder.encode(cowrString);\n\n    encodedResult += casing.caseChunk({\n      transformedString,\n      originalIndex: res1.originalIndex,\n    });\n  }\n\n  return casing.caseBull({\n    chunk: encodedResult,\n  });\n}\n\nfunction decodeBullpress(input) {\n  let output = \"\",\n    deCasedBull = /<Bull:(.*):>/g.exec(input)[1],\n    decodedResult = deCasedBull.match(/<Bull_Chunk:(.*?)\\|(\\d+):>/g);\n\n  if (!decodedResult) return;\n\n  for (let i = 0; i < decodedResult.length; i++) {\n    const chunk = decodedResult[i],\n      [, transformedString, originalIndex] = chunk.match(\n        /<Bull_Chunk:(.*)\\|(\\d+):>/,\n      ),\n      cowrString = BracketEncoder.decode(transformedString),\n      numbedKey = Cowrle.decodeCOWRLE(cowrString),\n      res1 = AvoidEnc.decode(numbedKey),\n      basedKey = BWT.inverseBurrowsWheelerTransform(res1, originalIndex);\n\n    output += base64.decode(basedKey);\n  }\n\n  return output;\n}\n\nconst eobj = {\n  encodeBullpress,\n  decodeBullpress,\n  \n  calculateCost,\n  calculateChunks,\n\n  CHUNK_LENGTH,\n  CHUCK_LENGTH_SPEED,\n  CHAR_EXCHANGE_COST,\n\n  casing,\n  AvoidEnc,\n  base64,\n\n  Cowrle,\n  BWT,\n  // Unused\n  Huffman,\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.bullpress = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;", "const {\n  encodeBullpress,\n  decodeBullpress,\n  CHUNK_LENGTH,\n\n  base64,\n  Cowrle,\n  BWT,\n  // Unused\n  Huffman,\n\n  calculateCost,\n  calculateChunks,\n} = require(\"./bullpress.js\");\n\n// ---\n\nfunction encode(input, logging = false) {\n  const start = Date.now(),\n    uriString = encodeURI(input);\n\n  function logIfEnabled(...messages) {\n    if (logging) console.log(...messages);\n  }\n\n  {\n    logIfEnabled(\"Encode COST:    \", calculateCost(uriString));\n  }\n\n  if (input.length < 1000) {\n    logIfEnabled(\"Original String:   \", input);\n    logIfEnabled(\".\");\n    logIfEnabled(\"Original String (With URI ENCODE):   \", uriString);\n    logIfEnabled(\"..\");\n    logIfEnabled();\n  }\n\n  const encodedString = encodeBullpress(uriString),\n    isOptimized = encodedString.length < uriString.length,\n    chunkCount = calculateChunks(uriString);\n\n  {\n    logIfEnabled(\n      \"Encoded String:   \",\n      encodedString < 1000\n        ? encodedString\n        : encodedString.slice(0, 1000) + \"...\",\n      \"\\n\",\n    );\n\n    logIfEnabled(\n      \"Optimization Status:   \",\n      isOptimized ? \"Optimized\" : \"Not Optimized\",\n      \"\\n\",\n    );\n\n    logIfEnabled(\n      \"Encoded Length:   \",\n      encodedString.length,\n      \"bytes (\",\n      (encodedString.length / 1024 / 1024).toFixed(2),\n      \"MB )\",\n    );\n\n    logIfEnabled(\"Chunk Count:   \", chunkCount);\n  }\n\n  const end = Date.now(),\n    timeSpent = end - start;\n\n  {\n    logIfEnabled(\"Processing Time:   \", timeSpent, \"ms\\n\");\n  }\n\n  return {\n    uriString,\n    encodedString,\n    isOptimized,\n    endTime: end,\n    startTime: start,\n    timeSpent,\n    chunkCount,\n    presumedTime: calculateCost(uriString).toFixed(2),\n  };\n}\n\nfunction encodeP(input, logging = false) {\n  return new Promise((resolve, reject) => resolve(encode(input, logging)));\n}\n\n// ---\n\nfunction decode(input, logging = false) {\n  function logIfEnabled(...messages) {\n    if (logging) console.log(...messages);\n  }\n\n  const start = Date.now(),\n    decodedString = decodeBullpress(input),\n    chunkCount = calculateChunks(decodedString);\n\n  {\n    logIfEnabled(\n      \"Decoded String:   \",\n      decodedString < 1000\n        ? decodedString\n        : decodedString.slice(0, 1000) + \"...\",\n      \"\\n\",\n    );\n\n    logIfEnabled(\n      \"Decoded Length:   \",\n      decodedString.length,\n      \"bytes (\",\n      (decodedString.length / 1024 / 1024).toFixed(2),\n      \"MB )\",\n    );\n\n    logIfEnabled(\"Chunk Count:   \", chunkCount);\n  }\n\n  const end = Date.now(),\n    timeSpent = end - start;\n\n  {\n    logIfEnabled(\"Processing Time:   \", timeSpent, \"ms\\n\");\n  }\n\n  return {\n    decodedString: decodeURI(decodedString),\n    endTime: end,\n    startTime: start,\n    timeSpent,\n    chunkCount,\n  };\n}\n\nfunction decodeP(input, logging = false) {\n  return new Promise((resolve, reject) => resolve(decode(input, logging)));\n}\n\n// ---\n\nfunction processEncoding(input, logging = false) {\n  // Logging if enabled\n  function logIfEnabled(...messages) {\n    if (logging) console.log(...messages);\n  }\n\n  logIfEnabled(\".-- Encoding... --.\\n\");\n\n  const // Encoding the input\n    encodeResult = encode(input, logging),\n    {\n      uriString,\n      isOptimized,\n      encodedString,\n      endTime: encodeEndTime,\n      startTime: encodeStartTime,\n      timeSpent: encodeTimeSpent,\n      chunkCount: encodeChunkCount,\n      presumedTime,\n    } = encodeResult;\n\n  logIfEnabled(\"'---- Encoded ----'\\n\");\n  logIfEnabled(\".-- Decoding... --.\\n\");\n\n  const // Decoding the encoded string\n    decodeResult = decode(encodedString, logging),\n    {\n      decodedString,\n      endTime: decodeEndTime,\n      startTime: decodeStartTime,\n      timeSpent: decodeTimeSpent,\n      chunkCount: decodeChunkCount,\n    } = decodeResult;\n\n  logIfEnabled(\"'---- Decoded ----'\\n\");\n\n  logIfEnabled(\".-- Doing Math... --.\\n\");\n\n  const // Calculating the time difference\n    timeDifference = decodeEndTime - encodeStartTime - presumedTime,\n    // Calculating the size difference\n    ELEN = encodedString.length,\n    OLEN = uriString.length,\n    SLEN = decodedString.length,\n    SDIFF = ELEN - OLEN,\n    PDIFF = ((SLEN - ELEN) / ELEN) * 100,\n    sizeDifference = SLEN - ELEN,\n    sizeDifferencePerc = (((ELEN - OLEN) / OLEN) * 100).toFixed(2),\n    RESULT = uriString === decodedString;\n\n  logIfEnabled(\"'-------------------'\\n\");\n  // ---\n\n  logIfEnabled(\".-- Doing Logs... --.\\n\");\n  {\n    logIfEnabled(\n      \"Original Length:   \",\n      uriString.length,\n      \"bytes (\",\n      (uriString.length / 1024 / 1024).toFixed(2),\n      \"MB )\",\n    );\n\n    logIfEnabled();\n    logIfEnabled(\"Chunk Length:   \", CHUNK_LENGTH, \"bytes\");\n    logIfEnabled(\n      \"Number of Chunks (Encoding):   \",\n      encodeChunkCount, // Displaying chunk count for encoding\n    );\n    logIfEnabled(\n      \"Number of Chunks (Decoding):   \",\n      decodeChunkCount, // Displaying chunk count for decoding\n    );\n\n    logIfEnabled();\n    logIfEnabled(\"Encoding time:   \", encodeTimeSpent, \"ms\");\n    logIfEnabled(\"Decoding time:   \", decodeEndTime - decodeStartTime, \"ms\");\n    logIfEnabled(\"Presumed time:   \", presumedTime, \"ms\");\n\n    logIfEnabled();\n    logIfEnabled(\"Sizing difference:   \", sizeDifference, \"bytes\");\n    logIfEnabled(\"Size difference %:   \", sizeDifferencePerc, \"%\");\n\n    logIfEnabled();\n    logIfEnabled(\n      \"Encoding Optimization:   \",\n      isOptimized ? \"Optimized\" : \"Not Optimized\",\n    );\n\n    logIfEnabled();\n    logIfEnabled(\"PDIFF:   \", PDIFF, \"%\");\n\n    logIfEnabled();\n    logIfEnabled(\n      \"Total Processing Time:   \",\n      encodeEndTime - encodeStartTime + decodeEndTime - decodeStartTime,\n      \"ms\",\n    );\n\n    logIfEnabled();\n    logIfEnabled(\"Presumption Accuracy:   \", timeDifference.toFixed(2), \"ms\");\n\n    logIfEnabled();\n    logIfEnabled(\"Result:   \", RESULT ? \"Success\" : \"Failure\");\n\n    logIfEnabled();\n  }\n  logIfEnabled(\"'-- Done logging! --'\\n\");\n\n  return {\n    decodedString: () => decodedString,\n    decodeEndTime,\n    decodeStartTime,\n    decodeTimeSpent,\n\n    encodedString: () => encodedString,\n    encodeEndTime,\n    encodeStartTime,\n    encodeTimeSpent,\n\n    isOptimized,\n    presumedTime,\n    result: RESULT,\n\n    sizeDifference,\n    sizeDifferencePerc,\n    timeDifference,\n\n    uriString: () => uriString,\n  };\n}\n\n// ---\n\nconst eobj = {\n  encode,\n  encodeP,\n  decode,\n  decodeP,\n  Test: processEncoding,\n\n  // @ Other exports\n  CHUNK_LENGTH,\n  calculateCost,\n  calculateChunks,\n\n  base64,\n  Cowrle,\n  BWT,\n  // Unused\n  Huffman,\n};\n\nif (typeof globalThis.window !== \"undefined\") globalThis.window.GoMooE1 = eobj;\nif (typeof module !== \"undefined\") module.exports = eobj;"],
  "mappings": "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",
  "names": ["require_cowrle", "__commonJSMin", "exports", "module", "encodeCOWRLEGenerator", "input", "encoded", "lastCount", "count", "inBrackets", "processChar", "char", "nextChar", "handleUniqueChar", "handleRepeatedChar", "handleSingleChar", "finalizeEncoding", "e", "decodeCOWRLEGenerator", "decoded", "i", "processCharacter", "character", "updateCount", "handleCharacter", "encodeCOWRLE", "decodeCOWRLE", "eobj", "require_BWT", "__commonJSMin", "exports", "module", "burrowsWheelerTransform", "input", "rotations", "i", "rotation", "transformedString", "originalIndex", "inverseBurrowsWheelerTransform", "table", "a", "b", "originalString", "currentIndex", "eobj", "require_huffman", "__commonJSMin", "exports", "module", "HuffmanNode", "char", "freq", "buildFrequencyMap", "str", "freqMap", "i", "buildHuffmanTree", "nodes", "a", "b", "left", "right", "newNode", "buildCodeMap", "node", "code", "codeMap", "encode", "encoded", "compress", "huffmanTree", "decompress", "decoded", "currentCode", "eobj", "require_cst", "__commonJSMin", "exports", "module", "CHAR_EXCHANGE_COST", "calculateCost", "string", "calculateChunks", "eobj", "require_casing", "__commonJSMin", "exports", "module", "eobj", "transformedString", "originalIndex", "chunk", "require_avoidE", "__commonJSMin", "exports", "module", "eobj", "input", "caser", "_", "match", "digit", "p1", "char", "require_bracketE", "__commonJSMin", "exports", "module", "eobj", "input", "require_base64", "__commonJSMin", "exports", "module", "base64", "input", "chars", "output", "i", "a", "b", "c", "index1", "index2", "index3", "index4", "index", "require_bullpress", "__commonJSMin", "exports", "module", "Cowrle", "BWT", "Huffman", "CHUNK_LENGTH", "CHUCK_LENGTH_SPEED", "CHAR_EXCHANGE_COST", "calculateCost", "calculateChunks", "casing", "AvoidEnc", "BracketEncoder", "base64", "encodeBullpress", "input", "chunkSize", "encodedResult", "i", "chunk", "basedKey", "res1", "numbedKey", "cowrString", "transformedString", "decodeBullpress", "output", "deCasedBull", "decodedResult", "originalIndex", "eobj", "require_bullpress", "__commonJSMin", "exports", "module", "encodeBullpress", "decodeBullpress", "CHUNK_LENGTH", "base64", "Cowrle", "BWT", "Huffman", "calculateCost", "calculateChunks", "encode", "input", "logging", "start", "uriString", "logIfEnabled", "messages", "encodedString", "isOptimized", "chunkCount", "end", "timeSpent", "encodeP", "resolve", "reject", "decode", "decodedString", "decodeP", "processEncoding", "encodeResult", "encodeEndTime", "encodeStartTime", "encodeTimeSpent", "encodeChunkCount", "presumedTime", "decodeResult", "decodeEndTime", "decodeStartTime", "decodeTimeSpent", "decodeChunkCount", "timeDifference", "ELEN", "OLEN", "SLEN", "SDIFF", "PDIFF", "sizeDifference", "sizeDifferencePerc", "RESULT", "eobj"]
}
